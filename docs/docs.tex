\documentclass[notitlepage]{article}

\title{LilyPad base class reference}
%\author{Artur Lidtke}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{morefloats}
\usepackage{fixltx2e}
%\usepackage[hidelinks]{hyperref}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{comment}
\graphicspath{{Figures/}}

\addtolength{\oddsidemargin}{-1cm}
\addtolength{\evensidemargin}{-1cm}
\addtolength{\textwidth}{2cm}

\usepackage{listings} % code listing
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{myred}{rgb}{0.8,0.1,0.1}

\lstdefinestyle{myCpp}
{
language=C++,
frame=none,
backgroundcolor={},
breaklines=true,
extendedchars=true,
keywordstyle=\color{mygreen},
numberstyle=\tiny\color{myred},
commentstyle=\color{blue},
basicstyle=\scriptsize\ttfamily, % the size of the fonts that are used for the code
morekeywords={&,>},
tabsize=2,
moredelim=**[is][\color{red}]{@}{@} % add @ delimiter and colour the stuff between in red
}

\begin{document}

\maketitle

%%%%%
\begin{abstract}
Somebody elseâ€™s code is always hard, let's break it down!

Most of the stuff in red has the same root issue. The variables are not collocated. Field.btype defines
where the variable is located. 0 is cell center, 1 is on the negative x face of the cell, 2 is on the
negative y face. This is why the interpolation changes depending on btype, and why the values of vorticity
and ke are averaged (because I'm taking the average of the face values to get the cell centered value),
and why it looks like I'm using first order difference in the gradient (actually second order central).

The CFL is my own condition. I haven't seen anyone else use it, though I'm not sure why. This is the
fundamental condition which determines stability of a connection diffusion problem. Maybe I should write it up in a tech note.

The quick scheme is called twice in bdim (predictor/corrector) which makes it second order overall.
I would guess bho is "b high-order", but I didn't write any of that code, so I'm not sure.

\end{abstract}

% =======================
\section{Used Postprocessing objects}

\begin{itemize}
\item \texttt{PVector} - Cartesian vector with x and y components
\end{itemize}

% =======================
\section{OrthoNormal}

% -----------------------
\subsection{Description}

Holds information describing a line segment.

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<float> l} - length of the line segment
\item \texttt{<float> nx} - normal vector x-component
\item \texttt{<float> ny} - normal vector y-component
\item \texttt{<float> tx} - x-tangent - unit vector between end points of the line segment
\item \texttt{<float> ty} - y-tangent
\item \texttt{<float> off} - normal offset - distance from the origin to the plane defined by this line segment
\item \texttt{<float> t1} - distance of the end points projected onto the tangent
\item \texttt{<float> t2}
\item \texttt{<PVector> cen} - centre of the line segment in the global coordinate system
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{Constructor}

Accepts two points in space and computes all the properties of the line segment they define.

\begin{lstlisting}[style=myCpp]
OrthoNormal(PVector x1, PVector x2 )
{
	// length of the line segment
	l = PVector.sub(x1,x2).mag();
	tx = (x2.x-x1.x)/l;    		// x tangent
	ty = (x2.y-x1.y)/l;    		// y tangent
	t1 = x1.x*tx+x1.y*ty;  		// tangent location of point 1
	t2 = x2.x*tx+x2.y*ty;  		// tangent location of point 2
	nx = -ty;
	ny = tx;     				// normal vector
	off = x1.x*nx+x1.y*ny; 		// normal offset
	cen = PVector.add(x1,x2);	// centriod
	cen.div(2.);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Distance}

Computes the distance between the line described by this instance of OrthoNormal object
and a gieven point. If no optional parameter is passed then a wrapper method is called
which passes \texttt{projected=true}. This means that the function computes the normal
distance from the point described by (x,y) by calling a dot product with the line nromal.
If \texttt{projected} is set to false, first the normal distance is computed as previously.
Then the distance between the intersection of normal direction of the line segment passing
through the point of interest and the tangential direction of the line segment is computed.
The return value is equal to the one computed using projected normal if the intersection
lies on the line segment or the sum of the normal and tangential distances if the
intersection point falls outside of the line segment.

\begin{lstlisting}[style=myCpp]
float distance( float x, float y, Boolean projected)
{
	float d = x*nx+y*ny-off; // normal distance to line 
	if(projected) return d;  // |distance|_n (signed, fastest)

	float d1 = x*tx+y*ty-t1; // tangent dis to start
	float d2 = x*tx+y*ty-t2; // tangent dis to end

	//    return sqrt(sq(d)+sq(max(0,-d1))+sq(max(0,d2))); // |distance|_2
	return abs(d)+max(0,-d1)+max(0,d2);              // |distance|_1 (faster)
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{tanCoord}

Returns the distance from the point of interest, (x,y), to the start of the line segment
along its tangential direction.

\begin{lstlisting}[style=myCpp]
float tanCoord( float x, float y )
{
	return min( max( (x*tx+y*ty-t1)/l, 0), 1 );
}
\end{lstlisting}

% =======================
\section{Scale}

% -----------------------
\subsection{Description}

Helps with organising display of data, allows interpolation between the actual mesh
and the pixelated grid. In the CFD each Cartesian axis has its own scale object.

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<float> inS} - start of the inner scale
\item \texttt{<float> inE} - end of the inner scale
\item \texttt{<float> outS} - same as above but for the outer scale
\item \texttt{<float> outE}
\item \texttt{<float> r} - ratio between the units of the outer and inner scales
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{Constructor}

Assembles the scale from components, explicitly assinging values to each of the fields.

\begin{lstlisting}[style=myCpp]
Scale( float inS, float inE, float outS, float outE )
{
	this.inS  = inS;
	this.inE  = inE;
	this.outS = outS;
	this.outE = outE;
	r = (outE-outS)/(inE-inS);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{OutB}

Converts from the inner to outer scale but making sure the returned value is
bounded between the start and end values of the outer scale.

\begin{lstlisting}[style=myCpp]
float outB( float in ){ return out(min(max(in,inS),inE));}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Out}

Converts the given coordinate in the inner scale into its corresponding value
in the outer scale.

\begin{lstlisting}[style=myCpp]
float out( float in ){ return (in-inS)*r+outS;} 
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{In}

Converts a given outer scale value into the inner scale.

\begin{lstlisting}[style=myCpp]
float in( float out ){ return (out-outS)/r+inS;}
\end{lstlisting}

% =======================
\section{Window}

% -----------------------
\subsection{Description}

Helps with organising display of data, allows interpolation between the actual mesh
and the pixelated grid.

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<Scale> x} - scale of the x axis
\item \texttt{<Scale> y} - scale of the y axis
\item \texttt{<int> x0} - beginning of the outer (display) scale in pixels for the x-axis
\item \texttt{<int> y0} - beginning of the outer scale for the y-axis in pixels
\item \texttt{<int> dx} - dimension of the x-axis in pixels
\item \texttt{<int> dy} - dimension of the y-axis in pixels
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{Constructor - from components}

Assembles the scale from components, explicitly assinging values to each of the fields.

\begin{lstlisting}[style=myCpp]
Window( float n0, float m0, float dn, float dm, int x0, int y0, int dx, int dy)
{
	// create the scale objects for both axes allowing interpolation onto the
	// display to be performed; inner scale is the CFD grid
	x = new Scale(n0,n0+dn,x0,x0+dx);
	y = new Scale(m0,m0+dm,y0,y0+dy);
	
	// assign the size and beginning of the display area
	this.x0 = x0;
	this.y0 = y0;
	this.dx = dx;
	this.dy = dy;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Constructor - basic}

Called by the basic LilyPad example. Only accepts the number of cells in both directions
and starts the inner grid from index 1. Read the size of the window using
global variables width and height, assigning both display axes to start at 0.

\begin{lstlisting}[style=myCpp]
Window( int n, int m)
{
	this( 1, 1, n-2, m-2, 0, 0, width, height );
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Inside}

Checks if the passed point fits within the limits of the display window.

\begin{lstlisting}[style=myCpp]
boolean inside( int x, int y )
{
	return( x>=x0 && x<=x0+dx && y>=y0 && y<=y0+dy );
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{ix/iy}

Converts from the cell index to pixel coordinate.

\begin{lstlisting}[style=myCpp]
float ix(int i){ return x.in((float)i);}
float iy(int i){ return y.in((float)i);}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{idx/idy}

Inverse conversion, used for something to do with mouse coordinates.

\begin{lstlisting}[style=myCpp]
float idx(int i){ return i/x.r;}
float idy(int i){ return i/y.r;}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{px/py}

Convert a pixel location to a cell index.

\begin{lstlisting}[style=myCpp]
int px(float i){ return (int)(x.out(i));}
int py(float i){ return (int)(y.out(i));}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{pdx/pdy}

Inverse transfrom in the pixel axis.

\begin{lstlisting}[style=myCpp]
int pdx(float i){ return (int)(x.r*i);}
int pdy(float i){ return (int)(y.r*i);}
\end{lstlisting}

% =======================
\section{Field}

% -----------------------
\subsection{Description}

Holds the information necessary to manipulate a scalar field,
such as keeping its values, advecting given a velocity field,
taking gradients or Laplacians, interpolating, etc.

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<float[][]> a} - array of internal field values, shape (n,m)
\item \texttt{<int> n, m} - number of grid points in x- and y-directions
\item \texttt{<int> btype} - defines where the variable is defined in the segregated storage scheme
	\begin{itemize}
		\item 0 - cell centre (e.g. pressure)
		\item 1 - negative x-face (e.g. x-velocity)
		\item 2 - negative y-face (e.g. y-velocity)
	\end{itemize}
\item \texttt{<float> bval} - value of the boundary condition (only used in certain cases)
\item \texttt{<bool> gradientExit} - flag specifying whether gradient outlet BC is used;
	important only if \texttt{btype} is 1 or 2, namely a vector field component is being considered
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{Constructor - from components}

Allocate memory to the field value array and set it equal
to the specified boundary value, \texttt{bval}.

\begin{lstlisting}[style=myCpp]
Field( int n, int m, int btype, float bval )
{
	this.n = n;
	this.m = m;
	this.a = new float[n][m];
	this.btype = btype;
	this.bval = bval;
	// sets the internal field values to bval
	this.eq(bval);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Laplacian}

Compute second spatial derivative of the field,
%
\begin{equation}
\nabla^2 \phi = \frac{\partial^2\phi}{\partial x^2}
	+ \frac{\partial^2\phi}{\partial y^2},
\end{equation}
%
using a 2nd order central scheme.

\begin{lstlisting}[style=myCpp]
Field laplacian ()
{
	// create an empty field d filled with zeros
	Field d = new Field( n, m );
	
	// loop over all INTERNAL cells (mind the end stencils)
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// use a 2nd order linear scheme in x- and y-directions
			// phi''(x) = [phi(x-delta_x) - 2 phi(x) + phi(x+delta_x)] / delta_x^2
			// recall that the code is dimensionless with
			// the grid size being the length-scale
			// this means we skip the delta_x and delta_y
			// in the denominator
			d.a[i][j] = -4*a[i][j] + a[i+1][j]
				+ a[i-1][j] + a[i][j+1] + a[i][j-1];
		}
	}
	// leave the boundary values equal to zero
	return d;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Gradient}

Compute the first spatial derivative of the field,
%
\begin{equation}
\nabla \phi = \frac{\partial\phi}{\partial x} \hat{\mathbf{i}}
	+ \frac{\partial\phi}{\partial y} \hat{\mathbf{j}},
\end{equation}
%
using a 2nd order central scheme.

\begin{lstlisting}[style=myCpp]
VectorField gradient()
{
	// this will hold the grad(a) values, initialise with zeros
	VectorField g = new VectorField(n,m,0,0);
	
	// loop over all internal faces
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// compute the x and y derivatives using a
			// 2nd order backward scheme (recall that gradients are stored at face centres so
			// g.x(x-delta_x/2,y) = (phi(x,y)-phi(x-delta_x,y)) / delta_x
			// phi'(x) = [phi(x) - phi(x-delta_x)] / delta_x
			g.x.a[i][j] = a[i][j]-a[i-1][j];
			g.y.a[i][j] = a[i][j]-a[i][j-1];
		}
	}
	
	// call the vectorField method to set the boundary values to zero in both directions (gradientExit=false)
	// this calls the Field::setBC() function on both x- and
	// y-components of the gradient function; x-dir is given
	// btype 1 and y-dir btype 2 - this causes the field values to be stored at the faces
	// as per staggered mesh formulation for a vector field
	g.setBC(); // issues?
	return g;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Advect}

Given a velocity field at this time step, \texttt{(u,v)}, and at the previous time step,
\texttt{(u0,v0)}, convect the scalar field in space. This uses the basic form of the scalar
transport equation,
%
\begin{equation}
\frac{\mathrm{D} \phi}{\mathrm{D}t} = 0,
\end{equation}
%
i.e. total derivative equals zero, assuming there are no
source terms on the RHS of the equation. To be more accurate, the function uses
two consecutive time step values with a 2nd order Runge-Kutta method and a
quadratic interpolation routine in space.

\begin{lstlisting}[style=myCpp]
void advect(float step, Field u, Field v, Field u0, Field v0)
{
	/* advect the field with the u, v velocity fields.
	Use a first order lagrangian method:
	Da/Dt = 0
	which translates into:
	a(t=dt,x,y) = a(t=0, x-dt*u(x,y), y-dt*v(x,y))
	
	The example code shows how diffusive this is 
	EDIT: by using an RK2 step to find x0 and using
	a quadratic interpolation, this method is second
	order and nondiffuse.
	
	EDIT2: by treating the old and new velocities 
	seperately, the method is second order in time.*/
	
	// create a copy of this field, keeping the current values
	Field a0 = new Field(this);
	
	// loop over all internal cells
	for( int i=1; i<n-1; i++)
	{
		for( int j=1; j<m-1; j++)
		{
			// select the interpolation point to be the +ve face of cell 0,
			// iterating up to -ve face of the last cell - i.e. all internal faces
			float x = i;
			float y = j;
			// correct for boundary values if necessary
			// Note: linear and quadratic interpolation methods will modify x and y by +0.5
			// if the field is stored at the -ve face centres because we want to convert the x-
			// and y-location into indices in the matrix. The interpolation method is generic and
			// so also makes sure the point at which interpolation is performed is valid, bounded inside
			// the domain and so on. If btype>0 the variable is stored at face centre, and hence 0.5\delta
			// before/below the (x,y) of the (i,j) cell
			if(btype==1) x -= 0.5;
			if(btype==2) y -= 0.5;
			// get the velocities at this time step
			float ax = -step*u.linear( x, y );
			float ay = -step*v.linear( x, y );
			// get the velocities at the previous time step
			// account for the fact that the interpolation point would have
			// "moved" back then as well
			float bx = -step*u0.linear( x+ax, y+ay );
			float by = -step*v0.linear( x+ax, y+ay );
			// assume that at the new time step field value is equal to
			// that at the previous time step at a location -dT*(u,v)
			// perform Runge-Kutta interpolation using three data points
			// to get the location in the field which would have been the current
			// value one time step ago
			// then use quadratic interpolation to get the field value there and
			// assign it to be the field value after update
			a[i][j] = a0.quadratic( x+0.5*(ax+bx), y+0.5*(ay+by) );
		}
	}
	// correct the BCs
	setBC();
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Quadratic}

Given a point of interest, \texttt{(x0,y0)}, interpolate the field values in space to
get a value at that location. The code uses

\begin{lstlisting}[style=myCpp]
float quadratic( float x0, float y0)
{
	// correct (x0,y0) if the field is stored at face centres
	float x = x0, y = y0;
	if(btype==1) x += 0.5;
	if(btype==2) y += 0.5;
	
	// get the indices of cells we need
	int i = round(x), j = round(y);
	
	// make sure we won't exceed the grid dimensions
	// perform linear interpolation if we do
	if( i>n-2 || i<1 || j>m-2 || j<1 )
		return linear( x0, y0 );
	
	// to interpolate we need x and y expressed about
	// the i-th and j-th cell
	x -= i;
	y -= j;
	
	// interpolate in the x-direction at 3 y-positions
	float e = quadratic1D(x,a[i-1][j-1],a[i][j-1],a[i+1][j-1]);
	float f = quadratic1D(x,a[i-1][j  ],a[i][j  ],a[i+1][j  ]);
	float g = quadratic1D(x,a[i-1][j+1],a[i][j+1],a[i+1][j+1]);
	
	// use the interpolated values to interpolate in the y-direction
	return quadratic1D(y,e,f,g);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Quadratic 1D}

Quadratic interpolation in 1D given a point of interest, \texttt{x}, and three field
values at consecutive grid points. The scheme is bounded between the data points
used for interpolation.

\begin{lstlisting}[style=myCpp]
float quadratic1D(float x, float e, float f, float g)
{
	// compute the value
	float x2 = x*x;
	float fx = f*(1.-x2);
	fx += (g*(x2+x)+e*(x2-x))*0.5;
	// bound the scheme between the specified field values
	fx = min(fx,max(e,f,g));
	fx = max(fx,min(e,f,g));
	return fx;
} 
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Linear}

Basic linear interpolation of the field values at a point of interest.

\begin{lstlisting}[style=myCpp]
// Interpolate the field at point (x0,y0)
float linear(float x0, float y0)
{
	// take the point of interest and make it bound between
	// 0.5 and x_max-0.5 - i.e. cell centres of 0th and N-1st cell (boundary cells)
	float x  = min(max(0.5,x0), n-0.5);
	if(btype==1) x += 0.5;
	
	// index of the cell around which we interpolate
	// make sure we do not pick N-1st cell (the last one)
	// casting <float>x to <int> will round down to the nearest integer
	// so that x should be between i and i+1
	int i = min( (int)x, n-2 ); 
	// weighting factor in the x-direction
	float s = x-i;
	
	float y  = min(max(0.5,y0), m-1.5);
	if(btype==2) y += 0.5;
	
	int j = min( (int)y, m-2 );
	float t = y-j;
	
	// if weighting factors are zero then just pick the field value (i,j)
	if(s==0 && t==0)
	{
		return a[i][j];
	}
	// perform linear interpolation
	// first do in the y-direction at both x-locations we need
	// then take the results and interpolate in the x-direction
	else
	{
		return  s*(t*a[i+1][j+1]+(1-t)*a[i+1][j])+
			(1-s)*(t*a[i  ][j+1]+(1-t)*a[i  ][j]);
	}
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Set BC}

This function takes care of all boundary condition related operations.
First apply von Neumann (normal gradient equal to zero) in both
x- and y-directions by setting the first and last grid point values to be equal to
those in the second and second-last cells. If the variable is stored at cell centres this is the only
step required. In the case of staggered variables, such as velocity x- and y-components, values
at the inlet and outlet faces are also prescribed. In a standard application with flow from left to right,
these would imply zero velocities in the y-direction at the walls, a fixed value BC at the left-hand side,
and an outlet BC at the RHS (\texttt{gradientExit} set to \texttt{true}).
\textcolor{red}{outlet BC is not your every-day zeroGradient, so what is it?}

\begin{lstlisting}[style=myCpp]
void setBC ()
{
	float s=0;

	// go over all y-indices
	for (int j=0 ; j<m ; j++ )
	{
		// set the 0th and n-1st (first and last) field values
		// to what they are one index into the domain
		// -> apply zero-gradient (von Neumann) BC at left and right sides
		a[0][j]   = a[1][j];
		a[n-1][j] = a[n-2][j];
	
		// if the field values are stored at the faces
		if(btype==1)
		{
			// if we have a zero-gradient type right-hand-side boundary
			// but fixed-value inlet then prescribe the value only there
			if(gradientExit)
			{
				// set inlet to fixed-value
				a[1][j] = bval;
				// s now holds an integral of the field values at the RHS boundary
				if(j>0 & j<m-1)
					s += a[n-1][j];          
			}
			// set the field values to the constant held in the class
			// if we have a fixed-value type BC set
			// do this to cells 1st cell into the domain at the LHS and last one at the RHS
			// this ensures zero-gradient at the LHS is maintained later on at the LHS
			else
			{
				a[1][j]   = bval;  
				a[n-1][j] = bval;
			}
		}
	}

	// go over all x-indices
	for (int i=0 ; i<n ; i++ )
	{
		// apply zero-gradient in the y-direction at top and bottom
		a[i][0]   = a[i][1];
		a[i][m-1] = a[i][m-2];
	
		// if the field values are stored at face centres set boundary values
		if(btype==2)
		{
			a[i][1]   = bval;  
			a[i][m-1] = bval;
		}
	}

	// set the RHS BC
	if(gradientExit)
	{
		// get the average values of s
		s /= float(m-2);
		// remove the mean value from the RHS cell and the boundary value
		for( int j=1; j<m-1; j++ )
			a[n-1][j] += bval-s;
	}
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Normal gradient}

Compute gradient in a normal direction where
\texttt{wnx} and \texttt{wny} are wall-normal x- and y-directions with their
\texttt{VectorField::x} holding the actual values of the gradient. See the function
\texttt{BDIM::get\_wn} for more information on how these are calculated.

The evaluated expression is
%
\begin{equation}
g = \mathbf{w}_n \cdot \nabla \phi
\end{equation}
%
where the gradient of the field is approximated using central scheme.

\begin{lstlisting}[style=myCpp]
Field normalGrad(VectorField wnx, VectorField wny)
{
	// result field
	Field g = new Field(n,m,0,0);
	
	// loop over all internal cells
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// compute the wall-normal gradient
			// approximate d(a)/dx_i using 2nd order central scheme
			// [a(i+1,j)-a(i-1,j)]/(2 delta_x), where delta_x = 1.0
			// take a dot-product with the wall-normal direction
			g.a[i][j] = 0.5*( wnx.x.a[i][j] * (a[i+1][j  ]-a[i-1][j  ])
							+ wny.x.a[i][j] * (a[i  ][j+1]-a[i  ][j-1]) );
		}
	}
	return g;
}
\end{lstlisting}

% =======================
\section{Vector field}

% -----------------------
\subsection{Description}

Class which makes use of the scalar field type to implement functionality
relevant to a vector quantity in 2D space.
It has some of its methods similar to those of a scalar field, such as assignment
or algebraic operators, normal gradient computation, etc. which are omitted here
fore brevity.

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<Field> x, y} - x- and y-components of the vector quantity, stored
	as \texttt{Field} types
\item \texttt{<int> n, m} - no. cells in x- and y-directions
\item \texttt{<float> CF} - QUICK parameter used to fit a polynomial through three points, set to 1/6 
\item \texttt{<float> S} - QUICK parameter used to tune the limiter, set to 10
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{Divergence}

What else, computes divergence of the field, in other words
%
\begin{equation}
\nabla \cdot \mathbf{U} = \frac{\partial u}{\partial x} + \frac{\partial v}{\partial y} .
\end{equation}
%
The derivative operator is approximated using 2nd order central difference.

\begin{lstlisting}[style=myCpp]
Field divergence ()
{
	// create the returned field
	Field d = new Field( n, m );
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// use 2nd order central difference to get the derivative
			// recall the vector field value (i) is at the negative face of cell (i)
			// therefore central difference at cell centre is (phi(i+1,j)-phi(i,j)) / delta_x
			d.a[i][j] = x.a[i+1][j  ]-x.a[i][j]+
						y.a[i  ][j+1]-y.a[i][j];
		}
	}
	return d;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Turbulent KE}

Computes a field which would return the turbulent kinetic energy if the stored
field was actually a velocity field. Typically, this evaluates to
%
\begin{equation}
TKE = \frac{1}{4} \left( u'^2 + v'^2 \right),
\end{equation}
%
where prime variables denote quantities fluctuating about the ensemble average at a given point.

\begin{lstlisting}[style=myCpp]
Field ke ()
{
	Field d = new Field( n, m );
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// first, take the average velocity in x- and y-directions; note that in the stream-wise
			// direction need to subtract the mean to get the fluctuating component; this has unit value
			// at faces i and i+1, therefore we subtract 2 from their sum
			// then square each fluctuating component and add; division by 2 taken in front of the square
			// operator, hence turns into 0.25
			d.a[i][j] = ( sq(x.a[i+1][j  ]+x.a[i][j]-2.0)
				 		+ sq(y.a[i  ][j+1]+y.a[i][j]    ) )*0.25;
		}
	}
	return d;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Vorticity}

Computes a field which would return the vorticity if the stored
field was actually a velocity field. In other words, the result is
%
\begin{equation}
\nabla \times \mathbf{U} = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}.
\end{equation}
%
Gradients are computed using central scheme.

\begin{lstlisting}[style=myCpp]
Field vorticity ()
{
	Field d = new Field( n, m );
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// take the gradients and then compute the value at the cell centre
			// Note: the flow is 2D, in 3D the result would be interpreted as the k_hat component of a vector field
			// gradients approximated using central difference
			// we need to first calculate the gradient at the positive and negative face
			// by using neighbouring faces; for instance, for +ve x face we take faces at (i+1,j-1)
			// and (i+1,j+1), subtract and divide by 2 delta_y; we repeat the same procedure at
			// (i,j-1) and (i,j+1) and take the mean of the two values; proceeding analogously in
			// the y-drection and taking the two divisions by 2 yields 0.25 and the following
			d.a[i][j] = 0.25*(	x.a[i  ][j-1]-x.a[i  ][j+1]+ // -du/dy
								x.a[i+1][j-1]-x.a[i+1][j+1]+ // -du/dy at face i+1
								y.a[i+1][j  ]-y.a[i-1][j  ]+ // dv/dx
								y.a[i+1][j+1]-y.a[i-1][j+1]); // dv/dx at face j+1
		}
	}
	return d;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Q criterion}

Computes a field which would return the Q criterion if the stored
field was actually a velocity field.
To define it, let us first denote the rate-of-strain tensor,
%
\begin{equation}
\mathbf{S} = \frac{1}{2}\left[\nabla\mathbf{U}+\left(\nabla\mathbf{U}\right)^T\right]
	= \frac{1}{2} \begin{bmatrix}
		\frac{\partial u}{\partial x} & \frac{\partial v}{\partial x} \\
		\frac{\partial u}{\partial y} & \frac{\partial v}{\partial y}
		\end{bmatrix}
	+ \frac{1}{2} \begin{bmatrix}
		\frac{\partial u}{\partial x} & \frac{\partial u}{\partial y} \\
		\frac{\partial v}{\partial x} & \frac{\partial v}{\partial y}
		\end{bmatrix}
	= \frac{1}{2} \begin{bmatrix}
		2\frac{\partial u}{\partial x} & \frac{\partial u}{\partial y} + \frac{\partial v}{\partial x} \\
		\frac{\partial v}{\partial x} + \frac{\partial u}{\partial y} & 2\frac{\partial v}{\partial y}
		\end{bmatrix} ,
\end{equation}
%
and vorticity tensor,
%
\begin{equation}
\mathbf{\Omega} = \frac{1}{2}\left[\nabla\mathbf{U}-\left(\nabla\mathbf{U}\right)^T\right]
	= \frac{1}{2} \begin{bmatrix}
		0 & \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y} \\
		\frac{\partial u}{\partial y} - \frac{\partial v}{\partial x} & 0
		\end{bmatrix} .
\end{equation}
%
Now, the vortex identification criterion may be written as
%
\begin{equation}
Q = \frac{1}{2} \left(\left|\mathbf{\Omega}\right|^2
	- \left|\mathbf{S}\right|^2 \right) > 0.
\end{equation}
\textcolor{red}{should this not be du\_i/dx\_j du\_j/dx\_i but without
excluding the option with i=j? also, would there be a minus between the
two terms? like eq. 1 in:}
\url{http://www.wseas.us/e-library/conferences/2011/Mexico/MAFLUH/MAFLUH-03.pdf}

\begin{lstlisting}[style=myCpp]
Field Qcrit ()
{
	Field q = new Field( n, m );
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			// compute finite differences at the (i,j) face using central scheme
			float dudx = 0.5*(x.a[i+1][j  ]-x.a[i-1][j  ]);
			float dudy = 0.5*(x.a[i  ][j+1]-x.a[i  ][j-1]);
			float dvdx = 0.5*(y.a[i+1][j  ]-y.a[i-1][j  ]);
			float dvdy = 0.5*(y.a[i  ][j+1]-y.a[i  ][j-1]);
			q.a[i][j] = dudx*dvdy-dvdx*dudy;
		}
	}
	return q;
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Diffusion}

Physically, this represents energy dissipation in the fluid. By assuming incompressibility, this
becomes
%
\begin{equation}
\nu \nabla^2 \mathbf{U} = \frac{\partial^2 u_k}{\partial x_i x_j} \mathbf{\hat{e}}_k \delta_{ij} = 
	\left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right) \mathbf{i}
	+\left( \frac{\partial^2 v}{\partial x^2} + \frac{\partial^2 v}{\partial y^2} \right) \mathbf{j} .
\end{equation}
%
Note that this function computes the Laplacian for a single component of a vector field only.
This is done using a second order linear scheme to compute the 2\textsuperscript{nd} spatial derivative around cell.
In one dimension this can be written as
%
\begin{equation}
\frac{\partial^2 \phi}{\partial x^2} \approx \phi(x-\Delta x) -2 \phi(x) + \phi(x + \Delta x) + O[\Delta x^2] .
\end{equation}

\begin{lstlisting}[style=myCpp]
float diffusion (Field b, int i, int j)
{
	// use second order linear scheme to compute the 2nd spatial derivative around cell i,j
	// compute d^2(phi)/d(x_i^2) values in the x- and y-directions and add
	return b.a[i+1][j] + b.a[i][j+1] - 4*b.a[i][j] + b.a[i-1][j] + b.a[i][j-1];
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Limiter}

This function accepts a value $a$ and makes sure this does not exceed the prescribed
upper and lower limits given as $b$ and $c$, respectively.

\begin{lstlisting}[style=myCpp]
float med(float a, float b, float c)
{
	return(max(min(a, b), min(max(a, b), c)));
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Face value interpolation}

In order to compute sum of the fluxes on each cell face, the cell-centre values
need to be interpolated.
The code uses Quadratic Upwind Interpolation for Convective Kinematics (QUICK) scheme in order to accomplish this. 
For example, for the east face of a cell P located at $x$ this would be
%
\begin{equation}
\begin{aligned}
\phi(x+&\Delta x/2) \approx \\
&\begin{cases}
	\frac{1}{2}(\phi(x + \Delta x) + \phi(x)) - CF (\phi(x- \Delta x) -2 \phi(x) + \phi(x+\Delta x)) & \mbox{if } u(x)>0 \\
	\frac{1}{2}(\phi(x + \Delta x) + \phi(x)) - CF (\phi(x) -2 \phi(x+\Delta x) + \phi(x+2\Delta x)) & \mbox{otherwise,}
\end{cases} 
\end{aligned}
\end{equation}
%
where $CF$ is a tuning coefficient.

\begin{lstlisting}[style=myCpp]
float bho(Field b, int i, int j, int d1, int d2, float uf)
{
	// this function gets used in the advection() method in order to provide field values at the
	// faces of the staggered cells; the returned value is the value at the (i+d1,j+d2) face
		
	// b - the field to be interpolated
	// i,j - cell indices
	// d1,d2 - tell us on which face from i,j the values are being computed
	// uf - convection velocity on the face of interest
	
	// this part remains the same irrespectively of where the flow is coming from
	// note that it represents simple linear interpolation between cell i,j and i+d1,j+d2
	float bf =  0.5*(b.a[i+d1][j+d2]+b.a[i][j]);
	
	// check if the flow is in the negative direction - if yes then we need to
	// shift the stencil by one node UPWIND
	if (d1*uf<0)
	{
		i += d1; 
		d1 = -d1;
	}
	
	if (d2*uf<0)
	{
		j += d2;
		d2 = -d2;
	}
	
	// if the stencil exceeds the grid dimensions then simply switch to a linear scheme
	if ( i>n-2 || i<2 || j>m-2 || j<2 ) return bf;
	
	// get the three values between which we want to fit a parabola
	float bc = b.a[i][j]; // value at the point of interest
	float bd = b.a[i+d1][j+d2]; // downwind value
	float bu = b.a[i-d1][j-d2]; // upwind value
	
	// bf is the typical QUICK implementation now, except the CF coefficient may be varied
	bf -= CF*(bd-2*bc+bu);
	
	// this is a test which approximates the face value by taking the upwind value,
	// and then going 10 d(phi)/dx from it
	float b1 = bu+S*(bc-bu);
	
	// this bounds the solution in some way between the cell value and a pre-set limit
	// with respect to the upwind cell
	return med(bf, bc,
		med(bc, bd, b1) // determine the upper bound for the limiter
		);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Advection}

Compute the advection of a field $b$ due to the velocity field described by this vector field object.
The return value is the sum of fluxes of $b$ into the $ij$ cell. Need to distinguish whether the values
of the $b$ field are being stored on the negative x-faces or otherwise in order to construct appropriate
staggered cells.

\textcolor{red}{todo: would be good to put in figures showing the mesh and staggered cells, highlighting how
	the advection works; something like fig 6.3 on pp 126 from Murthy 2002 \url{https://engineering.purdue.edu/ME608/webpage/main.pdf}}

\begin{lstlisting}[style=myCpp]
float advection (Field b, int i, int j)
{
	// face velocity values - w,e,s,n
	float uo, ue, vs, vn;
	
	// get values on the faces
	if (b.btype == 1)
	{
		// if the values of the field to be convected are stored at the -ve x face we need convective
		// velocities (\delta x_i)/2 away in each direction from the vertical faces
		uo = 0.5*(x.a[i-1][j  ]+x.a[i  ][j  ]); // value at cell centre of (i-1,j)
		ue = 0.5*(x.a[i+1][j  ]+x.a[i  ][j  ]); // c.c. value at (i,j)
		vs = 0.5*(y.a[i  ][j  ]+y.a[i-1][j  ]); // value at SW corner of (i,j) cell
		vn = 0.5*(y.a[i  ][j+1]+y.a[i-1][j+1]); // value at NW corner of (i,j) cell
	}
	else
	{
		uo = 0.5*(x.a[i  ][j-1]+x.a[i  ][j  ]); // value at SW corner of (i,j) cell
		ue = 0.5*(x.a[i+1][j-1]+x.a[i+1][j  ]); // value at SE corner of (i,j) cell
		vs = 0.5*(y.a[i  ][j-1]+y.a[i  ][j  ]); // c.c. value in the S cell of (i,j)
		vn = 0.5*(y.a[i  ][j  ]+y.a[i  ][j+1]); // c.c. value in the (i,j) cell
	}
	// return the sum of fluxes of b INTO this cell - interpolate using QUICK scheme
	return ( (uo*bho(b, i, j, -1, 0, uo) - ue*bho(b, i, j, 1, 0, ue))
		   + (vs*bho(b, i, j, 0, -1, vs) - vn*bho(b, i, j, 0, 1, vn)) );
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Advection - diffusion}

Combine the advection and diffusion terms and advance the flow field in time by
a single time step.
Takes the old velocity value, $u0$, computes the momentum flux into each cell,
accounts for diffusion, and updates the velocity field using a first-order
Euler time method. No external forces (like the pressure gradient) are accounted for.

\begin{lstlisting}[style=myCpp]
void AdvDif(VectorField u0, float dt, float nu)
{
	VectorField v = new VectorField(this);
	for ( int j=1; j<m-1; j++)
	{
		for ( int i=1; i<n-1; i++)
		{
			v.x.a[i][j] = (advection(x, i, j) + nu*diffusion(x, i, j))*dt + u0.x.a[i][j];
			v.y.a[i][j] = (advection(y, i, j) + nu*diffusion(y, i, j))*dt + u0.y.a[i][j];
		}
	}
	this.eq(v);   
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Semi-Lagrangian advection}

These two methods allow the components of the vector field to be advected with an external velocity
field just as any scalar variable would.

\begin{lstlisting}[style=myCpp]
// advect each of the components of this field as simple scalar variables given an external
// velocity field b; may use either 1st or 2nd order accuracy implemented in Field.pde
void advect( float dt, VectorField b )
{
	x.advect(dt,b);
	y.advect(dt,b);
}

void advect( float dt, VectorField b, VectorField b0 )
{
	x.advect(dt,b,b0);
	y.advect(dt,b,b0);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{CFL}

This computes a custom stability criterion, in a way similar to the Courant and Peclet numbers.

\begin{lstlisting}[style=myCpp]
float CFL(float nu)
{
	// find maximum velocity
	float b = abs(x.a[0][0])+abs(y.a[0][0]);
	float c;
	for ( int i=1; i<n-1; i++)
	{
		for ( int j=1; j<m-1; j++)
		{ 
			c = abs(x.a[i][j])+abs(y.a[i][j]);
			if (c>b) b=c;
		}
	}
	return 1./(b+3.*nu);
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Project}

\textcolor{red}{do properly}

\begin{lstlisting}[style=myCpp]
Field project ( VectorField coeffs, Field p, Field s )
{
	/* projects u,v onto a divergence-free field using
	div{coeffs*grad{p}} = div{u}  (1)
	u -= coeffs*grad{p}           (2)
	and returns the field p. all FDs are on unit cells */
	p = MGsolver( 20, new PoissonMatrix(coeffs), p , s );
	p.plusEq(-1*p.sum()/(float)((n-2)*(m-2)));
	VectorField dp = p.gradient();
	x.plusEq(coeffs.x.times(dp.x.times(-1)));
	y.plusEq(coeffs.y.times(dp.y.times(-1)));
	setBC();
	return p;
}
\end{lstlisting}

% =======================
\section{Boundary data immersion method - BDIM}

% -----------------------
\subsection{Description}

The core class in the code which implements the key functionality of the flow solver.

\textcolor{red}{reference Maertens \& Weymouth, "Accurate Cartesian-grid simulations of near-body flows at intermediate Reynolds numbers", 2015}

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<int> n, m} - number of cells in the uniform grid
\item \texttt{<float> dt} - time step of the simulation
\item \texttt{<float> nu} - dissipation constant, or viscosity
\item \texttt{<float> eps} - support of the BDIM kernels, given a constant value of 2 by default
\item \texttt{<PVector> g} - body force per unit mass (gravity), given a constant value of (0,0) by default
\item \texttt{<VectorField>}
	\begin{itemize}
	\item \texttt{u} - velocity field
	\item \texttt{del} - zeroth moment of the smoothing kernel
	\item \texttt{del1} - first moment of the smoothing kernel
	\item \texttt{c} - 
	\item \texttt{u0} - velocity field at the previous time step
	\item \texttt{ub} - body velocity field
	\item \texttt{wnx} - wall-normal direction to the nearest point on a body surface
	\item \texttt{wny} - \textcolor{red}{check how these are stored exactly}
	\item \texttt{distance} - distance from the nearest body to the cell centres
	\item \texttt{rhoi} - inverse of local fluid density (equal to 1 for single-phase flow)
	\end{itemize}
\item \texttt{<Field> p} - pressure field
\item \texttt{<boolean> QUICK} - whether to use the QUICK scheme in \textcolor{red}{check}
\item \texttt{<boolean> mu1} - whether to use the first moment of the smoothing kernel, set as true by default
\item \texttt{<boolean> adaptive} - whether to use adaptive \textcolor{red}{check}, defaults to false
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{Constructor}

The most important constructor. Several overloaded versions with simpler inputs also implemented.

\textcolor{red}{check if x-velocity will ever have bval 0, otherwise what's the point of the gradientExit check?}

\begin{lstlisting}[style=myCpp]
BDIM( int n, int m, float dt, Body body, VectorField uinit, float nu, boolean QUICK )
{
	// set the constants
	this.n = n;
	this.m = m;
	this.dt = dt;
	this.nu=nu;
	this.QUICK=QUICK;

	u = uinit;
	
	if(u.x.bval!=0) u.x.gradientExit = true; // use gradient exit for the axial velocity
	u0 = new VectorField(n,m,0,0);
	p = new Field(n,m);
	if(dt==0) setDt(); // adaptive time stepping for O(2) QUICK

	ub  = new VectorField(n,m,0,0);
	distance =  new VectorField(n, m, 10, 10);    
	del = new VectorField(n,m,1,1);
	del1 = new VectorField(n,m,0,0);
	rhoi = new VectorField(del); // initialise with ones
	c = new VectorField(del);
	wnx = new VectorField(n,m,0,0);
	wny = new VectorField(n,m,0,0);
	get_coeffs(body); // computes various coefficients for the flow
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Get coefficients}

Computes a range of coefficients needed to solve the flow.

\begin{lstlisting}[style=myCpp]
void get_coeffs( Body body )
{
	get_dist(body); // distance from the body
	get_del(); // 0th BDIM kernel
	get_del1(); // 1st BDIM kernel
	get_ub(body); // body velocity
	get_wn(body); // wall-normal direction to the nearest body
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Get distance}

Calculates distance from the specified body to all of the cell centres.

\begin{lstlisting}[style=myCpp]
void get_dist( Body body )
{
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			distance.x.a[i][j] = body.distance((float)(i-0.5), j);
			distance.y.a[i][j] = body.distance(i, (float)(j-0.5));
		}
	}
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Get zeroth kernel moment}

Compute the 0th order kernel moment for all cells given a body described using BDIM. This is called
for each cell inside the \texttt{get\_del()} method. As in \textcolor{red}{ref}, this is expressed as
%
\begin{equation}\label{eq:label}
\mu_0^\epsilon(d) =
\begin{cases}
\begin{aligned}
&\frac{1}{2} \left \lbrack 1 + \frac{d}{\epsilon} + \frac{1}{\pi} \mathrm{sin} \left(\frac{d}{\epsilon} \pi \right) \right \rbrack,& \lvert d \rvert < \epsilon , \\
&0,& d \leq -\epsilon, \\
&1,& d \geq \epsilon ,
\end{aligned}
\end{cases}
\end{equation}
%
where $\epsilon$ is a fixed kernel support width.

\begin{lstlisting}[style=myCpp]
// calculate the 0th BDIM kernel value given a distance from the nearest body
float delta0( float d )
{
	if( d <= -eps ) // point inside the body
	{
		return 0;
	}
	else if( d >= eps ) // point well inside the flow
	{
		return 1;
	}
	else // point at the body-fluid interface, need to blend the solid and fluid equations
	{
		// eq. 16a in Maertens & Weymouth 2015
		return 0.5*(1.0+d/eps+sin(PI*d/eps)/PI);
	} 
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Get first kernel moment}

Compute the 1st order kernel moment for all cells given a body described using BDIM. This is called
for each cell inside the \texttt{get\_del1()} method. As in \textcolor{red}{ref}, this is expressed as
%
\begin{equation}\label{eq:label}
\mu_1^\epsilon(d) =
\begin{cases}
\begin{aligned}
& \epsilon \left \lbrack \frac{1}{4} -\left( \frac{d}{2\epsilon} \right)^2 - \frac{1}{2\pi} \left(\frac{d}{\epsilon} \mathrm{sin} \left(\frac{d}{\epsilon}\pi\right)
	+\frac{1}{\pi} \left( 1+\mathrm{cos} \left( \frac{d}{\epsilon} \pi \right)\right)\right) \right \rbrack, &\lvert d \rvert < \epsilon , \\
&0, &\lvert d \rvert  \geq -\epsilon.
\end{aligned}
\end{cases}
\end{equation}

\begin{lstlisting}[style=myCpp]
// compute the 1st BDIM kernel
float delta1( float d )
{
	if( abs(d) >= eps) // outside of the blending region
	{
		return 0;
	}
	else // inside the blending region use eq. 16b from Maertens & Weymouth 2015
	{
		return 0.25*(eps-sq(d)/eps)-1/TWO_PI*(d*sin(d*PI/eps)+eps/PI*(1+cos(d*PI/eps)));
	} 
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Body velocity}

Computes velocity of the body, including translation and rotation, at each location within the numerical domain.

\begin{lstlisting}[style=myCpp]
// calculates the velocity of the body at each location in the flow
void get_ub( Body body )
{
	/* Immersed Velocity Field
	ub(x) = U(x)*(1-del(x))
	where U is the velocity of the body */
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			ub.x.a[i][j] = body.velocity(1,dt,(float)(i-0.5),j);
			ub.y.a[i][j] = body.velocity(2,dt,i,(float)(j-0.5));
		}
	}
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Wall-normal direction}

Evaluate wall-normal direction to the nearest point on an immersed body.

\textcolor{red}{check where this gets used and make sure the distances are from face centres}

\begin{lstlisting}[style=myCpp]
// computes wall normal direction of the closest body point
void get_wn(Body body)
{
	PVector wn;
	for ( int i=1 ; i<n-1 ; i++ )
	{
		for ( int j=1 ; j<m-1 ; j++ )
		{
			wn = body.WallNormal((float)(i-0.5),j);
			wnx.x.a[i][j]=wn.x;
			wny.x.a[i][j]=wn.y;
			wn = body.WallNormal(i,(float)(j-0.5));
			wnx.y.a[i][j]=wn.x;
			wny.y.a[i][j]=wn.y;
		}
	}   
}
\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{Update}

\begin{lstlisting}[style=myCpp]

\end{lstlisting}

% +++++++++++++++++++++++
\subsubsection{UpdateUP}

\begin{lstlisting}[style=myCpp]

\end{lstlisting}





\begin{comment}
% =======================
\section{a}

% -----------------------
\subsection{Description}

a

% -----------------------
\subsection{Internal fields}

\begin{itemize}
\item \texttt{<float> b} - a
\end{itemize}

% -----------------------
\subsection{Methods}

% +++++++++++++++++++++++
\subsubsection{a}

\begin{lstlisting}[style=myCpp]

\end{lstlisting}

\end{comment}

\end{document}
